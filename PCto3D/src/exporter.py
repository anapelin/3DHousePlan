"""
OBJ Exporter Module
Handles exporting processed geometry to OBJ format.
"""

import os
import open3d as o3d
import numpy as np
import logging
from pathlib import Path

logger = logging.getLogger(__name__)


class OBJExporter:
    """Exports processed geometry to OBJ format."""
    
    def __init__(self, config):
        """
        Initialize OBJ exporter with configuration.
        
        Args:
            config: Configuration dictionary
        """
        self.config = config
        self.output_folder = config['output']['folder']
        self.output_name = config['output']['obj_name']
        
    def export(self, geometry, output_path=None):
        """
        Export geometry to OBJ file.
        
        Args:
            geometry: Open3D geometry object
            output_path: Optional custom output path
            
        Returns:
            Path to exported OBJ file
        """
        if output_path is None:
            os.makedirs(self.output_folder, exist_ok=True)
            output_path = os.path.join(self.output_folder, self.output_name)
        
        output_path = Path(output_path)
        
        # Ensure .obj extension
        if output_path.suffix.lower() != '.obj':
            output_path = output_path.with_suffix('.obj')
        
        logger.info(f"Exporting to OBJ: {output_path}")
        
        # Convert point cloud to mesh if needed
        if isinstance(geometry, o3d.geometry.PointCloud):
            logger.info("Converting point cloud to mesh for export...")
            mesh = self._point_cloud_to_mesh(geometry)
        else:
            mesh = geometry
        
        # Ensure mesh has normals
        if not mesh.has_vertex_normals():
            mesh.compute_vertex_normals()
        
        # Export
        success = o3d.io.write_triangle_mesh(
            str(output_path),
            mesh,
            write_ascii=False,
            compressed=False,
            write_vertex_normals=True,
            write_vertex_colors=mesh.has_vertex_colors(),
            write_triangle_uvs=False
        )
        
        if success:
            logger.info(f"✓ Successfully exported to {output_path}")
            logger.info(f"  Vertices: {len(mesh.vertices)}")
            logger.info(f"  Triangles: {len(mesh.triangles)}")
            
            # Also export MTL file for materials
            mtl_path = output_path.with_suffix('.mtl')
            self._write_mtl_file(mtl_path, mesh)
            
            return output_path
        else:
            raise IOError(f"Failed to export mesh to {output_path}")
    
    def _point_cloud_to_mesh(self, pcd):
        """
        Convert point cloud to triangle mesh using Poisson reconstruction.
        
        Args:
            pcd: Open3D point cloud
            
        Returns:
            Triangle mesh
        """
        # Ensure normals exist
        if not pcd.has_normals():
            logger.info("Computing normals for mesh reconstruction...")
            pcd.estimate_normals(
                search_param=o3d.geometry.KDTreeSearchParamHybrid(
                    radius=0.1, max_nn=30
                )
            )
            pcd.orient_normals_consistent_tangent_plane(30)
        
        logger.info("Performing Poisson reconstruction...")
        mesh, densities = o3d.geometry.TriangleMesh.create_from_point_cloud_poisson(
            pcd, depth=9
        )
        
        # Remove low density vertices (likely artifacts)
        vertices_to_remove = densities < np.quantile(densities, 0.01)
        mesh.remove_vertices_by_mask(vertices_to_remove)
        
        # Transfer colors if available
        if pcd.has_colors():
            # Sample colors from point cloud
            pcd_tree = o3d.geometry.KDTreeFlann(pcd)
            colors = np.zeros((len(mesh.vertices), 3))
            
            for i, vertex in enumerate(mesh.vertices):
                [k, idx, _] = pcd_tree.search_knn_vector_3d(vertex, 1)
                if k > 0:
                    colors[i] = np.asarray(pcd.colors)[idx[0]]
            
            mesh.vertex_colors = o3d.utility.Vector3dVector(colors)
        
        logger.info(f"Reconstructed mesh: {len(mesh.vertices)} vertices, "
                   f"{len(mesh.triangles)} triangles")
        
        return mesh
    
    def _write_mtl_file(self, mtl_path, mesh):
        """
        Write MTL material file for the OBJ.
        
        Args:
            mtl_path: Path to MTL file
            mesh: Triangle mesh
        """
        with open(mtl_path, 'w') as f:
            f.write("# MTL file generated by PCto3D Pipeline\n")
            f.write("newmtl material_0\n")
            f.write("Ka 0.2 0.2 0.2\n")  # Ambient
            f.write("Kd 0.8 0.8 0.8\n")  # Diffuse
            f.write("Ks 0.5 0.5 0.5\n")  # Specular
            f.write("Ns 50.0\n")         # Shininess
            f.write("d 1.0\n")            # Transparency
            f.write("illum 2\n")          # Illumination model
        
        logger.info(f"✓ Material file saved: {mtl_path}")
    
    def export_segments_separately(self, pcd, output_dir=None):
        """
        Export each segment as a separate OBJ file.
        
        Args:
            pcd: Point cloud with segment_labels attribute
            output_dir: Directory to save segment files
            
        Returns:
            List of exported file paths
        """
        if not hasattr(pcd, 'segment_labels'):
            logger.warning("Point cloud has no segment labels, cannot export separately")
            return []
        
        if output_dir is None:
            output_dir = os.path.join(self.output_folder, 'segments')
        
        os.makedirs(output_dir, exist_ok=True)
        
        labels = pcd.segment_labels
        unique_labels = np.unique(labels[labels >= 0])
        
        exported_files = []
        
        logger.info(f"Exporting {len(unique_labels)} segments separately...")
        
        for label in unique_labels:
            mask = labels == label
            indices = np.where(mask)[0]
            
            # Extract segment
            segment_pcd = pcd.select_by_index(indices)
            
            # Export
            segment_path = os.path.join(
                output_dir,
                f"segment_{label:03d}.obj"
            )
            
            try:
                self.export(segment_pcd, segment_path)
                exported_files.append(segment_path)
            except Exception as e:
                logger.error(f"Failed to export segment {label}: {e}")
        
        logger.info(f"✓ Exported {len(exported_files)} segments to {output_dir}")
        
        return exported_files
    
    def save_intermediate(self, geometry, name, format='ply'):
        """
        Save intermediate processing results.
        
        Args:
            geometry: Open3D geometry object
            name: Name for the file
            format: File format ('ply' or 'obj')
        """
        if not self.config['output']['save_intermediate']:
            return
        
        output_dir = os.path.join(self.output_folder, 'intermediate')
        os.makedirs(output_dir, exist_ok=True)
        
        output_path = os.path.join(output_dir, f"{name}.{format}")
        
        try:
            if format == 'ply':
                if isinstance(geometry, o3d.geometry.PointCloud):
                    o3d.io.write_point_cloud(output_path, geometry)
                else:
                    o3d.io.write_triangle_mesh(output_path, geometry)
            elif format == 'obj':
                if isinstance(geometry, o3d.geometry.PointCloud):
                    mesh = self._point_cloud_to_mesh(geometry)
                    o3d.io.write_triangle_mesh(output_path, mesh)
                else:
                    o3d.io.write_triangle_mesh(output_path, geometry)
            
            logger.info(f"✓ Saved intermediate result: {output_path}")
        except Exception as e:
            logger.warning(f"Failed to save intermediate result {name}: {e}")

